# External Store

## 관심사의 분리(`Separation of concerns, SoC`)

하나의 시스템은 작은 부품이 모여서 만들어진다. 우리는 이미 작은 컴포넌트를 합쳐서 더 큰 컴포넌트를 만드는 방식으로 개발을 진행하고 있다.

### 거대한 일을 쉽고 효율적으로 해나는 법

자동차의 핸들, 바퀴, 골격 등 각 분야를 나눠서 특정 부문만을 담당해 개발하고 이를 잘 조합하면 방법을 이용한다면 훨씬 수월하게 자동차를 만들어 낼 수 있다.

### 소프트워에 개발에서의 관심사 분리

특정한 관심사에 따라 기능을 나누고, 각 기능을 독립적으로 개발한 뒤 이를 조합하는 방식으로 복잡한 소프트웨어를 구성해보자는 아이디어를 `관심사의 분리(Separation of concerns, SoC)`라고 합니다. 보통 `Layered Architecture`에선 사용자에게 가까운 것과 사용자에게서 먼 것으로 구분한다. 아래와 같이 구분을 할 수 있다.

1. 가장 가까운 건 UI를 다루는 부분
2. `Business Logic`을 다루는 부분
3. 그 너머에는 데이터에 접근하고 저장하는 부분

각 부분은 하나의 역할, 나의 관심사로 격리됨으로써 복잡도를 낮추게 된다.

거대한 프로그램이 아니라고 해도 흔히 Input -> Process -> Output이란 3단계의 코드를 적절히 구분만 해도 코드를 이해하고 유지보수 하는데 큰 도움이 된다. 하나의 Output은 다시 사용자에게 Input을 요청하게 되고, 일반적인 프로그램은 다음과 같이 계속 순환하는 구조가 된다.

1. `Input`: 프로그램 시작
2. `Process`: 프로그램 초기화
3. `Output`: 사용자에게 초기 UI 보여주기
4. `Input`: 사용자의 입력
5. `Process`: 사용자의 입력에 따라 처리
6. `Output`: 처리 결과 보여주기
7. `Input`: 사용자의 또 다른 입력
8. …반복…

널리 알려진 MVC로 거칠게 매핑하면 다음과 같다.

- Model -> Process
- View -> Output
- Controller -> Input

## Layered Architecture

`Layered Architecture`는 `관심사의 분리`에 따라 시스템을 유사항 책임(관심)을 지닌 Layer로 분리하고 각각의 Layer가 하위 Layer에만 의존하도록 구성하는 아키텍쳐 패턴이다.

- **전체적인 시스템의 결합도를 낮춘다**.
- 개발자의 **인지 과부하를 방지**한다.
- **재사용성을 높이고 유지보수성을 향상** 시킨다.

![Layered Architecture](./img/layered-architecture.png)

### 사용자 인터페이스 계층(User Interface Layer)

- 사용자 화면을 구성하는 것에 관심이 있습니다.
- 사용자 인터페이스를 어떻게 구성하고 상호 작용은 어떻게 수행할지에 대한 책임을 가지고 있습니다.
- 화면을 직접 서비스하지 않는다면 클라이언트로부터 요청을 받고, 응답하는 API를 정의합니다.

### 어플리케이션 계층(Application Layer)

- 도메인 계층의 비즈니스 로직과 인프라스트럭처 계층의 데이터 접근 로직을 조율하는 것에 관심이 있습니다.
- 실제 비즈니스 로직보단 고수준(high-level)에서 추상화 된 어플리케이션 기능을 표현합니다.

### 도메인 계층(Domain Layer)

- 핵심 비즈니스 로직을 수행하는 것에 관심이 있습니다.
- 세부적인 기술이나 외부 관심사에 의존하지 않고, 격리된 상태에서 순수한 비즈니스 로직을 수행합니다.
- Java 어플리케이션인 경우에 POJO(Plain Old Java Object) 객체를 사용해 비즈니스 로직을 구성합니다.

### 인프라스트럭처 계층(Infrastructure Layer)

- 상위 계층에게 기술적인 부분을 지원하는 것에 관심이 있습니다.
- 기술 종속성이 강한 구현체를 제공하는 계층입니다.
- 영속성 프레임워크, 프레임워크 설정, 외부 API 요청 기능, 이벤트 리스너(listener) 등이 있습니다.

